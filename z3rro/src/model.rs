//! SMT objects that can be evaluated in a model to return a concrete SMT type.

use std::{
    cell::RefCell,
    fmt::{self, Display},
    str::FromStr,
};

use num::{BigInt, BigRational};

use smtlib_lowlevel::{
    ast::{
        FunctionDef, GetModelResponse, Identifier, ModelResponse, QualIdentifier, SpecConstant,
        Term,
    },
    lexicon::{Decimal, Symbol},
};

use thiserror::Error;

use z3::{
    ast::{Ast, Bool, Dynamic, Int, Real},
    FuncDecl, FuncInterp, Model,
};

#[derive(Debug)]
pub enum ModelSource<'ctx> {
    Z3Model(Model<'ctx>),
    SwineModel(GetModelResponse<'ctx>),
}

/// A [`z3::Model`] which keeps track of the accessed constants. This is useful
/// to later print those constants which were not accessed by any of the
/// [`SmtEval`] implementations (e.g. stuff generated by Z3 we don't know
/// about). This way, we can print the whole model and pretty-print everything
/// we know, and then print the rest of the assignments in the model as well.
#[derive(Debug)]
pub struct InstrumentedModel<'ctx> {
    model: ModelSource<'ctx>,
    // TODO: turn this into a HashSet of FuncDecls when the type implements Hash
    accessed_decls: RefCell<im_rc::HashSet<String>>,
    accessed_exprs: RefCell<im_rc::HashSet<Dynamic<'ctx>>>,
}

impl<'ctx> InstrumentedModel<'ctx> {
    pub fn new(model: ModelSource<'ctx>) -> Self {
        InstrumentedModel {
            model,
            accessed_decls: Default::default(),
            accessed_exprs: Default::default(),
        }
    }

    /// Execute this function "atomically" on this model, rolling back any
    /// changes to the list of visited decls/exprs if the function fails with an
    /// error.
    pub fn atomically<T>(
        &self,
        f: impl FnOnce() -> Result<T, SmtEvalError>,
    ) -> Result<T, SmtEvalError> {
        let accessed_decls = self.accessed_decls.borrow().clone();
        let accessed_exprs = self.accessed_exprs.borrow().clone();
        let res = f();
        if res.is_err() {
            *self.accessed_decls.borrow_mut() = accessed_decls;
            *self.accessed_exprs.borrow_mut() = accessed_exprs;
        }
        res
    }

    /// Evaluate the given ast node in this model. `model_completion` indicates
    /// whether the node should be assigned a value even if it is not present in
    /// the model.
    pub fn eval<T: Ast<'ctx>>(&self, ast: &T, model_completion: bool) -> Option<T> {
        self.add_children_accessed(Dynamic::from_ast(ast));
        match &self.model {
            ModelSource::Z3Model(model) => {
                let res = model.eval(ast, model_completion)?;
                Some(res)
            }
            ModelSource::SwineModel(_) => todo!(),
        }
    }

    pub fn eval_ast_bool(&self, ast: &Bool<'ctx>) -> Option<Bool<'ctx>> {
        let name = ast.decl().name();

        if let ModelSource::SwineModel(s_model) = &self.model {
            match Self::find_fun_def(s_model, &name) {
                Some(fun_def) => match fun_def.3 {
                    Term::Identifier(QualIdentifier::Identifier(Identifier::Simple(Symbol(
                        "true",
                    )))) => Some(Bool::from_bool(ast.get_ctx(), true)),
                    Term::Identifier(QualIdentifier::Identifier(Identifier::Simple(Symbol(
                        "false",
                    )))) => Some(Bool::from_bool(ast.get_ctx(), false)),
                    _ => None,
                },
                None => None,
            }
        } else {
            None
        }
    }

    pub fn eval_ast_int(&self, ast: &Int<'ctx>) -> Option<Int<'ctx>> {
        let name = ast.decl().name();

        if let ModelSource::SwineModel(s_model) = &self.model {
            match Self::find_fun_def(s_model, &name) {
                Some(fun_def) => match fun_def.3 {
                    Term::SpecConstant(SpecConstant::Numeral(numeral)) => {
                        if let Ok(n) = numeral.into_u128() {
                            let n_str = n.to_string();
                            Int::from_str(ast.get_ctx(), &n_str)
                        } else {
                            None
                        }
                    }
                    _ => None,
                },
                None => None,
            }
        } else {
            None
        }
    }

    pub fn eval_ast_real(&self, ast: &Real<'ctx>) -> Option<Real<'ctx>> {
        let name = ast.decl().name();

        if let ModelSource::SwineModel(s_model) = &self.model {
            match Self::find_fun_def(s_model, &name) {
                Some(fun_def) => match fun_def.3 {
                    Term::SpecConstant(SpecConstant::Decimal(Decimal(d_str))) => {
                        if let Some((num, den)) = Self::from_str_to_num_den(d_str) {
                            Real::from_real_str(ast.get_ctx(), &num, &den)
                        } else {
                            None
                        }
                    }
                    _ => None,
                },
                None => None,
            }
        } else {
            None
        }
    }

    /// Convert a decimal string `d_str` into a pair of a numerator (`num`) and 
    /// a denominator (`den`) in the form of '[numeral]' strings such that: 
    /// d_str = num / den
    pub fn from_str_to_num_den(d_str: &str) -> Option<(String, String)> {
        if d_str.is_empty() {
            return None;
        }

        if let Some(pos) = d_str.find('.') {
            let den = "1".to_string() + &"0".repeat(d_str.len() - pos - 1);

            let mut num = d_str.to_string();
            num.remove(pos);
            num.trim_start_matches('0');

            if num.is_empty() {
                num = "0".to_string();
            }

            Some((num, den))
        } else {
            Some((d_str.to_string(), "1".to_string()))
        }
    }

    /// Find a `FunctionDef` object defined for a given symbol `symbol` within the `model_res`.
    pub fn find_fun_def(
        model_res: &GetModelResponse<'ctx>,
        symbol: &str,
    ) -> Option<&'ctx FunctionDef<'ctx>> {
        model_res.0.iter().find_map(|m_res| {
            if let ModelResponse::DefineFun(fun_def) = m_res {
                if fun_def.0.0 == symbol {
                    Some(fun_def)
                } else {
                    None
                }
            } else {
                None
            }
        })
    }

    /// Get the function interpretation for this `f`.
    pub fn get_func_interp(&self, f: &FuncDecl<'ctx>) -> Option<FuncInterp<'ctx>> {
        self.accessed_decls.borrow_mut().insert(f.name());
        todo!()
        // self.model.get_func_interp(f)
    }

    /// Add this ast node and all its children to the accessed set.
    fn add_children_accessed(&self, ast: Dynamic<'ctx>) {
        if ast.is_const() {
            self.accessed_decls.borrow_mut().insert(ast.decl().name());
        } else if ast.is_app() {
            for child in ast.children() {
                // some Z3 expressions might be extremely big because they
                // contain big expressions repeatedly. so the following check is
                // necessary to avoid walking through these expressions for a
                // very long time.
                let prev = self.accessed_exprs.borrow_mut().insert(child.clone());
                if prev.is_some() {
                    continue;
                }
                self.add_children_accessed(child);
            }
        }
    }

    /// Iterate over all function declarations that were not accessed using
    /// `eval` so far.
    pub fn iter_unaccessed(&self) -> impl Iterator<Item = FuncDecl<'ctx>> + '_ {
        todo!()
        /*
        self.model
            .iter()
            .filter(|decl| !self.accessed_decls.borrow().contains(&decl.name()))
         */
    }

    /// Reset the internally tracked accessed declarations and expressions.
    pub fn reset_accessed(&mut self) {
        self.accessed_decls.borrow_mut().clear();
        self.accessed_exprs.borrow_mut().clear();
    }

    pub fn into_model(self) -> Model<'ctx> {
        todo!()
        // self.model
    }
}

/// The [`Display`] implementation simply defers to the underlying
/// [`z3::Model`]'s implementation.
impl Display for InstrumentedModel<'_> {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        todo!()
        // f.write_fmt(format_args!("{}", &self.model))
    }
}

#[derive(Error, Debug, Clone)]
pub enum SmtEvalError {
    #[error("solver failed to evaluate a value")]
    EvalError,
    #[error("could not parse value from solver")]
    ParseError,
}

/// SMT objects that can be evaluated to a concrete value given a model.
pub trait SmtEval<'ctx> {
    type Value;

    // TODO: pass a model completion option?
    fn eval(&self, model: &InstrumentedModel<'ctx>) -> Result<Self::Value, SmtEvalError>;
}

impl<'ctx> SmtEval<'ctx> for Bool<'ctx> {
    type Value = bool;

    fn eval(&self, model: &InstrumentedModel<'ctx>) -> Result<bool, SmtEvalError> {
        model
            .eval(self, true)
            .ok_or(SmtEvalError::EvalError)?
            .as_bool()
            .ok_or(SmtEvalError::ParseError)
    }
}

impl<'ctx> SmtEval<'ctx> for Int<'ctx> {
    type Value = BigInt;

    fn eval(&self, model: &InstrumentedModel<'ctx>) -> Result<BigInt, SmtEvalError> {
        // TODO: Z3's as_i64 only returns an i64 value. is there something more complete?
        let value = model
            .eval(self, true)
            .ok_or(SmtEvalError::EvalError)?
            .as_i64()
            .ok_or(SmtEvalError::ParseError)?;
        Ok(BigInt::from(value))
    }
}

impl<'ctx> SmtEval<'ctx> for Real<'ctx> {
    type Value = BigRational;

    fn eval(&self, model: &InstrumentedModel<'ctx>) -> Result<Self::Value, SmtEvalError> {
        let res = model
            .eval(self, false) // TODO
            .ok_or(SmtEvalError::EvalError)?;

        // The .as_real() method only returns a pair of i64 values. If the
        // results don't fit in these types, we start some funky string parsing.
        if let Some((num, den)) = res.as_real() {
            Ok(BigRational::new(num.into(), den.into()))
        } else {
            // we parse a string of the form "(/ num.0 denom.0)"
            let division_expr = format!("{:?}", res);
            if !division_expr.starts_with("(/ ") || !division_expr.ends_with(".0)") {
                return Err(SmtEvalError::ParseError);
            }

            let mut parts = division_expr.split_ascii_whitespace();

            let first_part = parts.next().ok_or(SmtEvalError::ParseError)?;
            if first_part != "(/" {
                return Err(SmtEvalError::ParseError);
            }

            let second_part = parts.next().ok_or(SmtEvalError::ParseError)?;
            let second_part = second_part.replace(".0", "");
            let numerator = BigInt::from_str(&second_part).map_err(|_| SmtEvalError::ParseError)?;

            let third_part = parts.next().ok_or(SmtEvalError::ParseError)?;
            let third_part = third_part.replace(".0)", "");
            let denominator =
                BigInt::from_str(&third_part).map_err(|_| SmtEvalError::ParseError)?;

            Ok(BigRational::new(numerator, denominator))
        }
    }
}
