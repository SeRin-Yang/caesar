// Auto-generated by pgcl2heyvl from C4B_t303.pgcl
//
// HeyVL file to show
//     (0.5 * (x + 2)) + (0.5 * (y + 2)) >= ert[C](0)
// using k-induction with k = 3 and invariant = (0.5 * (x + 2)) + (0.5 * (y + 2))
// for the pGCL program C:
//
//     nat x;
//     nat y;
//     nat t;
//     nat r;
//     while (0 < x) {
//         {
//             r := 1;
//         } [1/3] {
//             {
//                 r := 2;
//             } [1/2] {
//                 r := 3;
//             }
//         }
//         x := x - r;
//         t := x;
//         x := y;
//         y := t;
//         tick(1);
//     }

coproc k_induction(init_x: UInt, init_y: UInt, init_t: UInt, init_r: UInt) -> (x: UInt, y: UInt, t: UInt, r: UInt)
    pre (0.5 * (init_x + 2)) + (0.5 * (init_y + 2))
    post 0
{
    var prob_choice: Bool
    x = init_x
    y = init_y
    t = init_t
    r = init_r
    coassert (0.5 * (x + 2)) + (0.5 * (y + 2))
    cohavoc r, t, x, y
    covalidate
    coassume (0.5 * (x + 2)) + (0.5 * (y + 2))
    if 0 < x {
        prob_choice = flip((1/3))
        if prob_choice {
            r = 1
        } else {
            prob_choice = flip((1/2))
            if prob_choice {
                r = 2
            } else {
                r = 3
            }
        }
        x = x - r
        t = x
        x = y
        y = t
        tick 1
        assert (0.5 * (x + 2)) + (0.5 * (y + 2))
        if 0 < x {
            prob_choice = flip((1/3))
            if prob_choice {
                r = 1
            } else {
                prob_choice = flip((1/2))
                if prob_choice {
                    r = 2
                } else {
                    r = 3
                }
            }
            x = x - r
            t = x
            x = y
            y = t
            tick 1
            assert (0.5 * (x + 2)) + (0.5 * (y + 2))
            if 0 < x {
                prob_choice = flip((1/3))
                if prob_choice {
                    r = 1
                } else {
                    prob_choice = flip((1/2))
                    if prob_choice {
                        r = 2
                    } else {
                        r = 3
                    }
                }
                x = x - r
                t = x
                x = y
                y = t
                tick 1
                assert (0.5 * (x + 2)) + (0.5 * (y + 2))
                assume 0
            } else {}
        } else {}
    } else {}
}
